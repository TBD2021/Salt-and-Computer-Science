# 算法题解-树

- [递归](#递归20230909)
  - [二叉树的高度：LeetCode-104](#LeetCode-104)

- [遍历](#遍历20230909)
  - [二叉树的深度优先遍历：LeetCode-102](#LeetCode-104)
    - [分别用递归和非递归的方式实现实现二叉树的先序、中序、后序遍历] 
  - [二叉树的宽度优先遍历：LeetCode-102](#LeetCode-104)
  
## 递归 <a name = "递归20230909">

一棵树要么是空树，要么有两个指针，每个指针指向一棵树。树是一种天生的递归结构，很多树的问题可以使用递归来处理。

### 二叉树的高度/Maximum Depth of Binary Tree <a name = "LeetCode-104">

[LeetCode-104. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)
```Java
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```

## 遍历 <a name = "遍历20230909">

### 二叉树的宽度优先遍历/Binary Tree Breadth First Traversal <a name = "LeetCode-102">

[LeetCode-102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)
**【解析】** 对于树，层次遍历等于宽度优先遍历。使用队列来存储次序信息。
**Solution 1** 1个队列，1个flag变量，2层循环
```Java
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        List<List<Integer>> res = new LinkedList<List<Integer>>();        

        if(root == null) return res;        

        q.add(root);
        while(!q.isEmpty()){
            int curLevelSize = q.size();
            List<Integer> curLevelNodes = new LinkedList<Integer>();
            for(int i=0; i<curLevelSize; i++) {
                if(q.peek().left != null) q.add(q.peek().left);
                if(q.peek().right != null) q.add(q.peek().right);
                curLevelNodes.add(q.poll().val);
            }
            res.add(curLevelNodes);
        }
        return res;
    }
```
**Solution 2** 1个队列，2个flag变量，1层循环
```Java
    public List<List<Integer>> levelOrder(TreeNode root) {       
        List<List<Integer>> res= new ArrayList<>();
        if(root==null)  return res;
        
        int i=0;
        int curLevelSize=0;
        int nextLevelSize=0;
        Queue<TreeNode> q= new LinkedList<>();
        TreeNode curNode=new TreeNode();

        q.add(root);
        curLevelSize=1;
        List<Integer> curLevelNodes=new ArrayList<>();
        while(!q.isEmpty()){
            curNode=q.poll();
            curLevelNodes.add(curNode.val);
            if(curNode.left!=null){
                nextLevelSize++;
                q.add(curNode.left);
            }
            if(curNode.right!=null){
                nextLevelSize++;
                q.add(curNode.right);
            }
            i++;
            if(i==curLevelSize){
                i=0;
                curLevelSize=nextLevelSize;
                nextLevelSize=0;
                res.add(curLevelNodes);
                curLevelNodes=new ArrayList<>();
            }            
        }
        return res;
    }
```

