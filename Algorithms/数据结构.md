# 数据结构

- [树](#树20230909)
  - 树的遍历 
    - 深度优先遍历/DFS：用栈存储次序信息
    - 宽度优先遍历/BFS：用队列存储次序信息
- [图/Graphs](#图20230909)
  - 概述
  - 图的底层实现：邻接矩阵、邻接表
  - 图的遍历：
    - 深度优先遍历/DFS：用栈存储次序信息
    - 宽度优先遍历/BFS：用队列存储次序信息

## 树 <a name = "树20230909">

### 树的遍历

**I. 深度优先遍历/Depth First Traversal**

**II. 宽度优先遍历&层次遍历/Breadth First Traversal&Level Order Traversal**

**定义**

- 宽度优先遍历：It explores all the nodes at the present depth before moving on to the nodes at the next depth level
- 层次遍历：Each node at level i is processed before any node at level i+1

1) 对于Tree，宽度优先遍历和层次遍历是完全没有区别的。
2) 对于Graph，有时并不是每一层都是完整的，此时层次遍历的概念就不再适用，而宽度优先遍历的概念依然适用。

```html
level
  1          1
            / \
  2        /   3
          /   /
  3      2   4

Level-order traversal: 1, 3, 2, 4.
Breadth-first traversal: 1, 2, 3, 4.
```

## 图/Graphs <a name = "图20230909">

### 概述

A graph *G=(V, E)* is defined by a finite set of *vertices V*, and a set of *edges E* consisting of ordered or unordered pairs of vertices from *V*. 

**特性**

- Directed vs. Undirected Graphs
- Weighted vs. Unweighted Graphs
<br>

- Simple vs. Non-Simple Graphs
- Sparse vs. Dense Graphs

### 图的底层实现

Assume the graph *G=(V, E)* contains *|V|* vertices and *|E|* edges.
- 邻接矩阵/Adjacency Matrix：一个*|V|×|V|* 二维数组（矩阵），在二维数组中保存每两个节点间的联通关系
- 邻接表/Adjaceny list：一个长度为*|V|*的哈希表，其中每个数据对的Key值存储节点，Value值存储从该节点出发的所有相邻节点

**Time Complexity Costs**

|   |Adijacency list|Adjacency Matrix|
|---|---|---|
|Store graph|O(\|V\|+\|E\|)|O(\|V\|<sup>2</sup>)|
|Add vertex|O(1)|O(\|V\|<sup>2</sup>)|
|Add edge|O(1)|O(1)|
|Remove vertex|O(\|E\|)|O(\|V\|<sup>2</sup>)|
|Remove Edge|O(\|V\|)|O(1)|
|判断已知位置的两个节点是否邻接|O(\|V\|)|O(1)|

- 大多数情况，邻接表都优于邻接矩阵
- 稀疏图(节点较多，边较少)适合用邻接表存储，稠密图(节点较少，边较多)适合用邻接矩阵存储

### 图的遍历

**I. 深度优先遍历/Depth First Traversal**

**II. 宽度优先遍历/Breadth First Traversal**

BFS visits the sibling vertices before visiting the child vertices, and a queue is used in the search process.

**算法**

1. 从源节点开始，把相邻节点依次放入队列。
2. 弹出一个节点，把该节点下一个**没有进过队列**的邻接节点放入队列。
3. 重复步骤1、2，直到队列变成空队列。







