# 算法题解-图与图算法
- DFS/BFS
  - [Flood Fill Algorithms](#Flood_Fill20230910)
    - [LeetCode-733: Flood Fill](#LeetCode-733)
  - [岛屿问题/the Number of Islands](#the_Number_of_Islands20230923)
    - [LeetCode-200: Number of Islands](#LeetCode-200)
 - 拓扑排序
   
## DFS/BFS

### 泛洪算法(Flood Fill Algorithms) <a name ="Flood_Fill20230910">

Flood fill, is a flooding algorithm that determines and alters the area connected to a given node in a multi-dimensional array with some matching attribute.

**核心思路**

就是图的遍历，DFS、BFS都可以。每次访问一个未访问过的节点，将其淹没(染色)。使用DFS、BFS都可以。

|4-way flood fill using a stack|4-way flood fill using a queue|
|---|---|
|<img src="https://github.com/TBD2021/Salt-and-Computer-Science/blob/main/Algorithms/img/floodfill1_animation_stack.gif" width=200px>|<img src="https://github.com/TBD2021/Salt-and-Computer-Science/blob/main/Algorithms/img/floodfill1_animation_queue.gif" width=200px>|

[LeetCode-733. Flood Fill (Easy)<a name ="LeetCode-733">](https://leetcode.com/problems/flood-fill/)

**图的DFS/BFS算法** 

```Java
//4-direction Flood Fill Method
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        graphDFS(image,sr,sc,color);
        return image;      
    }

//Graph DFS, Recursive Implementation
    public void graphDFS(int[][] image, int sr, int sc, int color) {
        int rowNum=image[0].length;
        int columnNum=image.length;
        int preColor=preColor=image[sr][sc];

        if(preColor==color)         //Important: 如果不做这个判定，会反复擦写同一个位置，导致死循环
            return;
        else{
            image[sr][sc]=color;
            if(sr-1>=0&&image[sr-1][sc]==preColor){
                graphDFS(image,sr-1,sc,color);
            }
            if(sr+1<columnNum&&image[sr+1][sc]==preColor){
                graphDFS(image,sr+1,sc,color);
            }
            if(sc-1>=0&&image[sr][sc-1]==preColor){
                graphDFS(image,sr,sc-1,color);
            }
            if(sc+1<rowNum&&image[sr][sc+1]==preColor){
                graphDFS(image,sr,sc+1,color);
            }
        }
        return;  
    }
```

### 岛屿问题/the Number of Islands <a name ="the_Number_of_Islands20230923">

**描述**

地图上有两种地形，陆地和水域。返回地图中的岛屿数量。

**核心思路**

构建一个矩阵来表示地图。在矩阵中，用“1”表示陆地，用“0”表示水域。岛屿就是一组聚集在一起的“1”。

方法1： 使用图的DFS/BFS算法（也就是泛洪算法）。每次调用DFS/BFS遍历，将1个岛涂色。扫描整个矩阵，计数总共涂色了几个岛。

方法2： 使用并查集。将每个岛上的所有地图格合并到一个集合中，计数总共有多少个集合。并查集解法可以进一步优化为并行算法，现将地图矩阵分割到多个CPU上进行统计，再将每个CPU得到的集合合并结果与地图分割边界上的元素信息重新归纳合并，得出最后的整体结果。

**【算法-DFS】**

1. Scan the matrix from (0,0) to (N, M).
2. If the current element is ‘1’, start a DFS.
3. In the DFS traversal, mark every visited node.
4. Count the number of islands as the number of nodes that trigger the DFS.
5. Return count.

- Cost
  - 时间复杂度：O(M * N), where M and N are the size of the matrix.
  - 空间复杂度：O(M * N).

**【算法-BFS】**

1. Scan the matrix from (0,0) till (N, M).
2. If the current element is ‘1’, start a BFS.
3. Consider a queue and put the current node into the queue.
4. Iteratively visit its neighbours vertically and horizontally and mark them as visited.
5. The count is the total number of times the BFS has been invoked.
6. Return count.

- Cost
  - 时间复杂度：O(M * N), where M and N is the size of the matrix.
  - 空间复杂度：O(min(M,N))

[LeetCode-200. Number of Islands (Medium)<a name ="LeetCode-200">](https://leetcode.com/problems/number-of-islands/)

**方法1：图的DFS/BFS算法** 

```Java
    public int rSize;   //row size
    public int cSize;   //column size

    public int numIslands(char[][] grid) {
        int res=0;
        rSize=grid.length;
        cSize=grid[0].length;

       for (int i=0; i<rSize; i++){
            for(int j=0;j<cSize;j++){
                if(grid[i][j]=='1'){
                    dfsGraph(grid, i, j, '1','0');
                    res++;
                }
            }
        }
        return res;        
    }

//Function: Graph DFS, Recursive Implementation
    public void dfsGraph(char[][]grid, int rNum, int cNum, char pre, char cur){
        if(rNum-1>=0&&grid[rNum-1][cNum]==pre){
            grid[rNum-1][cNum]=cur;
            dfsGraph(grid, rNum-1, cNum, pre,cur);
        }
        if(rNum+1<rSize&&grid[rNum+1][cNum]==pre){
            grid[rNum+1][cNum]=cur;
            dfsGraph(grid, rNum+1, cNum, pre,cur);
        }
        if(cNum-1>=0&&grid[rNum][cNum-1]==pre){
            grid[rNum][cNum-1]=cur;
            dfsGraph(grid, rNum, cNum-1, pre,cur);
        }
        if(cNum+1<cSize&&grid[rNum][cNum+1]==pre){
            grid[rNum][cNum+1]=cur;
            dfsGraph(grid, rNum, cNum+1, pre,cur);
        }
        return;
    }
```

- [任务依赖性/Task Dependency](#Task_Dependency20231001)
  - [LeetCode-207, 210: Course Schedule I、II ](#LeetCode-207)

## 拓扑排序

### 任务依赖性/Task Dependency <a name ="Task_Dependency20231001">

[LeetCode-210: Course Schedule II (Medium) <a name ="LeetCode-210">](https://leetcode.com/problems/course-schedule-ii/)

**Solution:**

```Java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
     // Convert prerequisites to a Adijacency List Graph representation  
        ArrayList<Integer> [] G = new ArrayList[numCourses];
        for(int i =0; i<numCourses;i++) G[i]=new ArrayList();
        int[] degree=new int[numCourses];

        for(int[] e: prerequisites){
            G[e[1]].add(e[0]);
            degree[e[0]]++;
        }

      // Topological Sort using BFS
        Queue<Integer> topoQueue = new LinkedList<>();
        int topoSize=0;        
        int[] res=new int[numCourses];

        for(int i=0;i<numCourses;i++){
            if(degree[i]==0)    
                topoQueue.offer(i);
        }
        while(!topoQueue.isEmpty()){
            int cur=topoQueue.remove();
            res[topoSize]=cur;
            topoSize++;
            for(int j=0;j<G[cur].size();j++){
                degree[G[cur].get(j)]--;
                if(degree[G[cur].get(j)]==0)
                    topoQueue.offer(G[cur].get(j));
            }
        } 
        if(topoSize==numCourses){
            return  res;
        }else
            return new int[0];
    }
```

