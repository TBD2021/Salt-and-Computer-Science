# 算法题解-任务依懒性
- [任务依赖性/Task Dependency](#Task_Dependency20231001)
  - [LeetCode-207, 210: Course Schedule I、II ](#LeetCode-207)

## 任务依赖性/Task Dependency <a name ="Task_Dependency20231001">

### Course Schedule I、II <a name ="LeetCode-207">

**【解析】** 两道题本质是一样的，只是I题只需判断是否存在拓扑序列，II题还需在存在拓扑序列的情况下输出一个拓扑序列。

[LeetCode-207. Course Schedule (Medium)](https://leetcode.com/problems/course-schedule/))

**Solution:**
```
   public boolean canFinish(int numCourses, int[][] prerequisites) {
    // Convert prerequisites to a Adijacency List Graph representation  
        ArrayList<Integer> [] G = new ArrayList[numCourses];
        for(int i =0; i<numCourses;i++) G[i]=new ArrayList();
        int[] degree=new int[numCourses];

        for(int[] e: prerequisites){
            G[e[1]].add(e[0]);
            degree[e[0]]++;
        }

    // Topological Sort using BFS
        Queue<Integer> topoQueue = new LinkedList<>();
        int topoSize=0;

        for(int i=0;i<numCourses;i++){
            if(degree[i]==0)    
                topoQueue.offer(i);
        }
        while(!topoQueue.isEmpty()){
            int cur=topoQueue.remove();
            topoSize++;
            for(int j=0;j<G[cur].size();j++){
                degree[G[cur].get(j)]--;
                if(degree[G[cur].get(j)]==0)
                    topoQueue.offer(G[cur].get(j));
            }
        } 
        return topoSize==numCourses;        
    }
```




[LeetCode-207, 210: Course Schedule I、II (Easy)](https://leetcode.com/problems/flood-fill/)

**【解析】** 图的遍历，DFS，BFS都可以。

- [LeetCode-144, 94, 145：分别用递归和非递归的方式实现实现二叉树的先序、中序、后序遍历](#LeetCode-144)
