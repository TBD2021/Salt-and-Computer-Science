# 算法题解-任务依懒性
- [任务依赖性/Task Dependency](#Task_Dependency20231001)
  - [LeetCode-207, 210: Course Schedule I、II ](#LeetCode-207)

## 任务依赖性/Task Dependency <a name ="Task_Dependency20231001">

### Course Schedule I、II <a name ="LeetCode-207">

**【解析】** 两道题本质是一样的，只是I题只需判断是否存在拓扑序列，II题还需在存在拓扑序列的情况下输出一个拓扑序列。

[LeetCode-207. Course Schedule (Medium)](https://leetcode.com/problems/course-schedule/))

**Solution:**

```Java
   public boolean canFinish(int numCourses, int[][] prerequisites) {
    // Convert prerequisites to a Adijacency List Graph representation  
        ArrayList<Integer> [] G = new ArrayList[numCourses];
        for(int i =0; i<numCourses;i++) G[i]=new ArrayList();
        int[] degree=new int[numCourses];

        for(int[] e: prerequisites){
            G[e[1]].add(e[0]);
            degree[e[0]]++;
        }

    // Topological Sort using BFS
        Queue<Integer> topoQueue = new LinkedList<>();
        int topoSize=0;

        for(int i=0;i<numCourses;i++){
            if(degree[i]==0)    
                topoQueue.offer(i);
        }
        while(!topoQueue.isEmpty()){
            int cur=topoQueue.remove();
            topoSize++;
            for(int j=0;j<G[cur].size();j++){
                degree[G[cur].get(j)]--;
                if(degree[G[cur].get(j)]==0)
                    topoQueue.offer(G[cur].get(j));
            }
        } 
        return topoSize==numCourses;        
    }
```

[LeetCode-210: Course Schedule II (Medium)](https://leetcode.com/problems/course-schedule-ii/))

**Solution:**

```Java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
 // Convert prerequisites to a Adijacency List Graph representation  
        ArrayList<Integer> [] G = new ArrayList[numCourses];
        for(int i =0; i<numCourses;i++) G[i]=new ArrayList();
        int[] degree=new int[numCourses];

        for(int[] e: prerequisites){
            G[e[1]].add(e[0]);
            degree[e[0]]++;
        }

// Topological Sort using BFS
        Queue<Integer> topoQueue = new LinkedList<>();
        int topoSize=0;        
        int[] res=new int[numCourses];

        for(int i=0;i<numCourses;i++){
            if(degree[i]==0)    
                topoQueue.offer(i);
        }
        while(!topoQueue.isEmpty()){
            int cur=topoQueue.remove();
            res[topoSize]=cur;
            topoSize++;
            for(int j=0;j<G[cur].size();j++){
                degree[G[cur].get(j)]--;
                if(degree[G[cur].get(j)]==0)
                    topoQueue.offer(G[cur].get(j));
            }
        } 

        if(topoSize==numCourses){
            return  res;
        }else
            return new int[0];
    }
```


