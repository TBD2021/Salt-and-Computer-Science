# 最长回文子串

- 概述
- 暴力算法：中心扩展算法
- Manacher 算法

## 概述

**最长回文子串问题**

给定一个长度为 n 的字符串 s，找到它的最长回文子串(the Longest Palindromic Substring)的长度。

回文串：设 t<sub>rev</sub> 是 t 的反转字符串。如果 t=t<sub>rev</sub>，那么字符串 t 是一个回文串。

Manacher 算法是一个用来查找一个字符串中的最长回文子串的线性算法。总的来说，最长回文子串问题有多种解法，但是 Manacher 算法（Manacher's Alogorithm）比其他算法要压倒性地简单，且在时间和空间复杂度上具有更小的常数。

## 暴力算法：中心扩展算法

暴力算法的原理很简单：对给定的字符串 s 中的每一个字符，记录以该字符为中心向左右扩展所构成的最长回文子串的长度。

由于这种暴力算法只能找到奇数长度的回文子串，无法找到偶数长度的回文子串，因此需要改进：在字符串 s 的每个字符前后都插入一个特殊字符，这个字符可以任意选取，不会影响最终结果。经过这一预处理操作，字符串的长度由 n 扩展到了 2n+1。对扩展后的字符串使用暴力算法找到最长回文子串，将结果除以 2 即可。

<div align="center">
    <img src="https://github.com/TBD2021/Salt-and-Computer-Science/blob/main/Algorithms/img/Manacher1.svg" width="400px">
</div>

**【暴力算法：中心扩展算法】**

给定长度为 n 的字符串 s, 找到它的最大回文子串的长度。

1. 在字符串 s 的每个字符前后都插入一个特殊字符。
2. 对字符串 s 中的每一个字符从头部到尾部依次访问。
   3. 以该字符为中心向两边扩展，记录它所对应的最长回文子串的长度。
3. 找出各个字符的最长回文子串长度中的最大值，再除以 2 即为结果。

- **时间复杂度：** O(n<sup>2</sup>)
- **空间复杂度：** O(1)

## Manacher 算法

Manacher 算法的核心在于利用已搜索过的回文字符串的信息。

**【Manacher 算法】**

设：
  - manacherStr[]: 经过预处理，对给定字符串 s[] 间隔插入特殊字符后得到的字符串。
  - 回文中心 center : 每次进行中心扩展的中心字符。
  - 回文半径：该回文中心字符对应的最长回文子串的长度的一半。
  - 回文直径：回文半径*2-1
  - 回文半径数组 p[]：该数组记录 manacherStr[]中每一个字符对应的最长回文半径。
  - 最右回文边界 rBorder：遍历字符串时，每个字符的最长回文子串都会有个右边界，
最右回文边界是所有已知右边界中最右的位置。rBorder 的值保持单增。

1. 将长度为 n 的原字符串 s[] 转换为 manacherStr[]；回文中心 center 初始化为 -1；rBorder 初始化为 -1。创建半径数组 p[]。
   - 实际代码存在一个小偏差，rBorder 实际设为最右回文边界的位置+1。 
3. 从数组下标 i=0 到 n-1，逐一遍历 manacherStr[]，后续存在多个分支：
    1. 分支1： 当 i>rBorder 时，用暴力中心扩展算法计算当前 i 位置字符的最长回文长度，并判断和更新 rBorder 和 center。

(要更新的字符，位置 i 超出了最右回文边界 rBorder，没有已知的回文字符子串信息可以利用，因此使用暴力算法重新计算。)

    2. 
  
