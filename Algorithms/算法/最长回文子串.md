# 最长回文子串

- 概述
- 暴力算法：中心扩展算法
- Manacher 算法

## 概述

**最长回文子串问题**

给定一个长度为 n 的字符串 s，找到它的最长回文子串(the Longest Palindromic Substring)的长度。

回文串：设 t<sub>rev</sub> 是 t 的反转字符串。如果 t=t<sub>rev</sub>，那么字符串 t 是一个回文串。

Manacher 算法是一个用来查找一个字符串中的最长回文子串的线性算法。总的来说，最长回文子串问题有多种解法，但是 Manacher 算法（Manacher's Alogorithm）比其他算法要压倒性地简单，且在时间和空间复杂度上具有更小的常数。

## 暴力算法：中心扩展算法

暴力算法的原理很简单：对给定的字符串 s 中的每一个字符，记录以该字符为中心向左右扩展所构成的最长回文子串的长度。

由于这种暴力算法只能找到奇数长度的回文子串，无法找到偶数长度的回文子串，因此需要改进：在字符串 s 的每个字符前后都插入一个特殊字符，这个字符可以任意选取，不会影响最终结果。经过这一预处理操作，字符串的长度由 n 扩展到了 2n+1。对扩展后的字符串使用暴力算法找到最长回文子串，将结果除以 2 即可。

<div align="center">
    <img src="https://github.com/TBD2021/Salt-and-Computer-Science/blob/main/Algorithms/img/Manacher1.svg" width="400px">
</div>

**【暴力算法：中心扩展算法】**

给定长度为 n 的字符串 s, 找到它的最大回文子串的长度。

1. 在字符串 s 的每个字符前后都插入一个特殊字符。
2. 对字符串 s 中的每一个字符从头部到尾部依次访问。
   3. 以该字符为中心向两边扩展，记录它所对应的最长回文子串的长度。
3. 找出各个字符的最长回文子串长度中的最大值，再除以 2 即为结果。

- **时间复杂度：** O(n<sup>2</sup>)
- **空间复杂度：** O(1)

## Manacher 算法

Manacher 算法的核心在于利用已搜索过的回文字符串的信息进行加速。

**【Manacher 算法】**

设：
  - manacherStr[]: 经过预处理，对给定字符串 s[] 间隔插入特殊字符后得到的字符串。
  - 回文半径：回文子串的长度的一半。
  - 回文直径：回文半径*2-1
  - 回文半径数组 p[]：该数组记录 manacherStr[]中每一个字符对应的最长回文半径。
  - 最右回文中心 C : 目前已知的回文串中，右边界 R 最靠右的回文串的中心位置。
  - 最右回文边界 R：遍历字符串时，每个字符的最长回文子串都会有个右边界，最右回文边界是所有已知右边界中最右的位置。R 的值保持单增。
  - 设 L 是 R 关于 C 的对称位置。L 与 R 之间的字符串\[L，R]是回文串。
  - 设 i' 是 i 关于 C 的对称位置，也就是 i'=2*C-i，因为字符串时从左到右遍历的，因此 i'<i，i'的回文信息（保存在半径数组p\[i']中的）是已知的，可以根据该信息判断是否进行加速。

算法：

1. 将长度为 n 的原字符串 s[] 转换为 manacherStr[]；最右回文中心 C 初始化为 -1；R 初始化为 -1。创建半径数组 p[]。
   - 实际代码存在一个小偏差，R 实际设为最右回文边界的位置+1。 
2. 从数组下标 i=0 到 n-1，逐一遍历 manacherStr[]，后续存在多个分支：

<div align="center">
    <img src="https://github.com/TBD2021/Salt-and-Computer-Science/blob/main/Algorithms/img/Manacher2.svg" width="400px">
</div>

    1. 分支 1：当 i>R 时，用暴力中心扩展算法计算当前 i 位置字符的最长回文长度，并判断和更新 R 和 C。(也就是说，要更新的字符 i，位置超出了最右回文边界 R，没有已知的回文字符子串信息可以利用，因此使用暴力算法重新计算。)
    2. 分支 2-1：当 i≤R 时，如果 i' 的回文区域在\[L，R]之内，因为整个\[L，R]是一个回文串，那么可以直接得出回文半径 p\[i]=p\[i']。       
    4. 分支 2-2：当 i≤R 时，如果 i' 的回文半径左边界超过 L，这种情况仅能保证 i 的回文半径是 i 到 R, \[i，R]。
    5. 分支 2-3： i' 的回文半径左边界恰好与 L 重合，此时 i 的回文半径至少是 i 到 R, 对于 R 更外侧部分，继续用暴力中心扩展算法求解。
   
4. 更新 C 和 R：如果求出的 P\[ i ] 的右边界大于当前的 R ，就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 左侧，所以一旦有更右边的 R 就要更新 R。

- **时间复杂度：** O(n)，

每个字符最多遍历2次。

- **空间复杂度：** O(n)
