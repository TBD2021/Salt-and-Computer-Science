# Lecture3：比较排序算法

**Topics:**
- [概述](#概述20231013)
- [O(n<sup>2</sup>)算法：插入排序、选择排序、冒泡排序](#比较排序A20231013)
- O(nlogn)算法：快速排序、归并排序、堆排序
- [Trade-Off：6种比较排序算法](#TradeOff20231013)
    
## 概述 <a name="概述20231013">

**排序问题**

**输入：** n 个数的序列 \<a<sub>1</sub>，a<sub>2</sub>，...，a<sub>n</sub>\>。

**输出：** 输入序列的一个重新排列 \<a'<sub>1</sub>，a'<sub>2</sub>，...，a'<sub>n</sub>\>，使 a'<sub>1</sub>≤a'<sub>2</sub>≤...≤a'<sub>n</sub>。

**比较排序算法**

比较排序（Comparison Sort）是指通过对序列中的元素进行比较来实现排序，包括冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序。关于比较排序算法的性能极限，已证明的是，任何n个输入的比较排序算法的最坏情况下的时间复杂度的下界为 Ω（nlogn），而如果能够利用非比较的其他方法来获得有关输入序列中的排序信息，则可以突破Ω（nlogn）的下界。
  
## O(n<sup>2</sup>)算法：插入排序、选择排序、冒泡排序 <a name="比较排序A20231013">

### 插入排序(Insertion Sort)

插入排序：将未排序序列中的数据与已排序序列中的数据从后向前逐一比较，找到相应位置插入。

## Trade-Off：6种比较排序算法 <a name="TradeOff20231013">

|排序算法|时间复杂度<br>(Worst Case)|时间复杂度<br>(Average)|时间复杂度<br>(Best Case)|空间复杂度|稳定性|代码复杂度|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|冒泡排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|稳定|简单|
|直接选择排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(1)|不稳定|简单|
|直接插入排序|O(n<sup>2</sup>)|O(n<sup>2</sup>)|O(n)|O(1)|稳定|简单|
|归并排序|O(nlogn)|O(nlogn)|O(n)|O(n)|稳定|较复杂|
|快速排序|O(n<sup>2</sup>)|O(nlogn)|O(nlogn)|Average: O(log n)<br> Worst Case: O(n)|不稳定|较复杂|			
|堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定|复杂|

*排序算法的稳定性：输入序列中两个值相同的元素在经过排序后，如果在输出序列中能够保持相对顺序不变，那么这个排序算法就是稳定的。*

**结论：**
- 目前没有时间复杂度为 O(nlogn)，同时有具有稳定性，且空间复杂度为 O（1）的排序算法：
  - 时间复杂度：快速排序＜归并排序＜堆排序。快速排序消耗的常数项时间最低，是最快最常用的。
  - 稳定性：归并排序具有稳定性。
  - 空间复杂度：堆排序的空间复杂度最低。
- 输入数据的规模较小时，时间复杂度 O（n<sup>2</sup>）的算法快于 O（nlogn）的算法。
  - 小样本时，插入排序是最常用的。 


