# 算法题解

- 数据结构
  - [树](#树20231028)
    - [递归方法解决树的问题](#递归20230909)
      - [LeetCode-104：二叉树的高度](#LeetCode-104) 
    - [树的遍历](#遍历20230909)  
      - [LeetCode-144, 94, 145：分别用递归和非递归的方式实现实现二叉树的先序、中序、后序遍历](#LeetCode-144)
      - [LeetCode-102：二叉树的层次遍历](#LeetCode-102)

 - 应用
   - 图的DFS/BFS
     - 泛洪算法(Flood Fill Algorithm)
     - 岛屿问题(the Number of Islands)
   - 拓扑排序
     - 任务依赖性(Task Dependency)

## 数据结构

<a name = "树20231028">
  
### 树

**递归方法解决树的问题** <a name = "递归20230909">

一棵树要么是空树，要么有指针，每个指针指向一棵树。树是一种天生的递归结构，很多树的问题可以使用递归来处理。

- 二叉树的高度/Maximum Depth of Binary Tree <a name = "LeetCode-104">

[LeetCode-104. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)
```Java
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
    }
```

**树的遍历** <a name = "遍历20230909">

- 分别用递归和非递归的方式实现实现二叉树的先序、中序、后序遍历 <a name = "LeetCode-144">

递归方法能够解决的问题，非递归方法都能够用栈来解决，因为递归方法就是利用系统栈保存信息的。二叉树的先序、中序、后序遍历中，后序遍历的非递归方式实现要更麻烦一些，需要前后两个指针及一些条件判断。

[LeetCode-144. Binary Tree Preorder Traversal (Easy)](https://leetcode.com/problems/binary-tree-preorder-traversal/)

**Solution 1:** 递归方式
```Java
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res= new ArrayList<Integer>();
        if(root!=null)  {
            res.add(root.val);
            res.addAll(preorderTraversal(root.left));
            res.addAll(preorderTraversal(root.right));
        }else{
            return res;
        }
        return res;      
    }
```

**Solution 2:** 非递归方式
```Java
    public List<Integer> preorderTraversal(TreeNode root) {
        List <Integer> res= new ArrayList<>();
        Stack <TreeNode> stack= new Stack<>();
        TreeNode tmp=new TreeNode();

        if(root==null)  return res;
        else{
            stack.push(root);
            while(!stack.empty()==true){
                tmp=stack.pop();
                res.add(tmp.val);
                if(tmp.right!=null) stack.push(tmp.right);
                if(tmp.left!=null) stack.push(tmp.left);
            }
            return res;
        }        
    }

```
[LeetCode-94. Binary Tree Inorder Traversal (Easy)](https://leetcode.com/problems/binary-tree-inorder-traversal/)

**Solution 1:** 递归方式

```Java
    public List<Integer> inorderTraversal(TreeNode root) {
        List <Integer> res=new ArrayList();
        if(root==null)  return res;
        else{
            res.addAll(inorderTraversal(root.left));
            res.add(root.val);
            res.addAll(inorderTraversal(root.right));
            return res;
        }
    }
```

**Solution 2:** 非递归方式
```Java
    public List<Integer> inorderTraversal(TreeNode root) {
        List <Integer> res= new ArrayList<>();
        Stack <TreeNode> stack= new Stack<>();
        TreeNode tmp=new TreeNode();

        tmp=root;
        while(tmp!=null||!stack.empty()==true){
            while(tmp!=null){
                stack.push(tmp);
                tmp=tmp.left;
            }
            tmp=stack.pop();
            res.add(tmp.val);
            tmp=tmp.right;
        }
          return res;
    }
```
[LeetCode-94. Binary Tree Postorder Traversal (Easy)](https://leetcode.com/problems/binary-tree-postorder-traversal/)

**Solution 1:** 递归方式
```Java
    public List<Integer> postorderTraversal(TreeNode root) {
        List <Integer> res= new ArrayList<>();
        if(root==null)  return res;
        else{
            res.addAll(postorderTraversal(root.left));
            res.addAll(postorderTraversal(root.right));
            res.add(root.val);
            return res;
        }    
      }
```

**Solution 2:** 非递归方式
```Java
    public List<Integer> postorderTraversal(TreeNode root) {
        List <Integer> res=new ArrayList<>();
        Stack <TreeNode> stack=new Stack<>();
        TreeNode cur=root;
        TreeNode pre=null;

        while(cur!=null||!stack.empty()){
            while(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }
            cur=stack.pop();
            if(cur.right!=null&&pre!=cur.right){
                stack.push(cur);
                cur=cur.right;
            }
            else{
                res.add(cur.val);
                pre=cur;
                cur=null;
            }
        }
        return res;
    }

```

- 二叉树的层次遍历/Binary Tree Level Order Traversal <a name = "LeetCode-102">

[LeetCode-102. Binary Tree Level Order Traversal (Medium)](https://leetcode.com/problems/binary-tree-level-order-traversal/)

对于树而言，层次遍历等于宽度优先遍历。使用队列来存储次序信息。

**Solution 1:** 1个队列，1个flag变量，2层循环
```Java
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> q = new LinkedList<TreeNode>();
        List<List<Integer>> res = new LinkedList<List<Integer>>();        

        if(root == null) return res;        

        q.add(root);
        while(!q.isEmpty()){
            int curLevelSize = q.size();
            List<Integer> curLevelNodes = new LinkedList<Integer>();
            for(int i=0; i<curLevelSize; i++) {
                if(q.peek().left != null) q.add(q.peek().left);
                if(q.peek().right != null) q.add(q.peek().right);
                curLevelNodes.add(q.poll().val);
            }
            res.add(curLevelNodes);
        }
        return res;
    }
```

**Solution 2:** 1个队列，2个flag变量，1层循环
```Java
    public List<List<Integer>> levelOrder(TreeNode root) {       
        List<List<Integer>> res= new ArrayList<>();
        if(root==null)  return res;
        
        int i=0;
        int curLevelSize=0;
        int nextLevelSize=0;
        Queue<TreeNode> q= new LinkedList<>();
        TreeNode curNode=new TreeNode();

        q.add(root);
        curLevelSize=1;
        List<Integer> curLevelNodes=new ArrayList<>();
        while(!q.isEmpty()){
            curNode=q.poll();
            curLevelNodes.add(curNode.val);
            if(curNode.left!=null){
                nextLevelSize++;
                q.add(curNode.left);
            }
            if(curNode.right!=null){
                nextLevelSize++;
                q.add(curNode.right);
            }
            i++;
            if(i==curLevelSize){
                i=0;
                curLevelSize=nextLevelSize;
                nextLevelSize=0;
                res.add(curLevelNodes);
                curLevelNodes=new ArrayList<>();
            }            
        }
        return res;
    }
```


## 参考资料

- [LeetCode](https://leetcode.com/)
- [CS Nodes-LeetCode 题解](https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/Leetcode%20%E9%A2%98%E8%A7%A3/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.html)
- 程序员代码面试指南，by 左程云，2015.
